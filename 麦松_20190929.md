### 今日学习
#### 闭包的概念
由于JavaScript中，函数是对象，对象是属性的集合，而属性的值又可以是对象，则在函数内定义函数成为理所当然，如果在函数func内部声明函数inner，然后在函数外部调用inner，这个过程即产生了一个闭包。

#### 闭包的特性
```
var outter = [];  
function clouseTest () {  
    var array = ["one", "two", "three", "four"];  
    for(var i = 0; i < array.length;i++){  
       var x = {};  
       x.no = i;  
       x.text = array[i];  
       x.invoke = function(){  
           print(i);  
       }  
       outter.push(x);  
    }  
}  
   
//调用这个函数  
clouseTest();  
   
print(outter[0].invoke());  
print(outter[1].invoke());  
print(outter[2].invoke());  
print(outter[3].invoke());
```
初学者可能会得出这样的答案：
0
1
2
3
然而，运行这个程序，得到的结果为：
4
4
4
4
其实，在每次迭代的时候，这样的语句x.invoke = function(){print(i);}并没有被执行，只是构建了一个函数体为”print(i);”的函数对象，如此而已。而当i=4时，迭代停止，外部函数返回，当再去调用outter[0].invoke()时，i的值依旧为4，因此outter数组中的每一个元素的invoke都返回i的值：4。
#### 解决方法
可以声明一个匿名函数，并立即执行它：
```
var outter = [];  
   
function clouseTest2(){  
    var array = ["one", "two", "three", "four"];  
    for(var i = 0; i < array.length;i++){  
       var x = {};  
       x.no = i;  
       x.text = array[i];  
       x.invoke = function(no){  
           return function(){  
              print(no);  
           }  
       }(i);  
       outter.push(x);  
    }    
}  
   
clouseTest2();  
```
为x.invoke赋值的时候，先运行一个可以返回一个函数的函数，然后立即执行之，这样，x.invoke的每一次迭代器时相当与执行这样的语句：
```
//x == 0  
x.invoke = function(){print(0);}  
//x == 1  
x.invoke = function(){print(1);}  
//x == 2  
x.invoke = function(){print(2);}  
//x == 3  
x.invoke = function(){print(3);}  
```
这样就可以得到正确结果了。闭包允许引用存在于外部函数中的变量。然而，它并不是使用该变量创建时的值，相反，它使用外部函数中该变量最后的值。
#### 闭包的用途
现在，闭包的概念已经清晰了，闭包还有很多用途。事实上，通过使用闭包，可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。
#### 匿名自执行函数
所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么就可以使用闭包：
```
var datamodel = {  
    table : [],  
    tree : {}  
};  
   
(function(dm){  
    for(var i = 0; i < dm.table.rows; i++){  
       var row = dm.table.rows[i];  
       for(var j = 0; j < row.cells; i++){  
           drawCell(i, j);  
       }  
    }  
     
    //build dm.tree    
})(datamodel);
```
创建一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。
#### 缓存
如果有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。
```
var CachedSearchBox = (function(){  
    var cache = {},  
       count = [];  
    return {  
       attachSearchBox : function(dsid){  
           if(dsid in cache){//如果结果在缓存中  
              return cache[dsid];//直接返回缓存中的对象  
           }  
           var fsb = new uikit.webctrl.SearchBox(dsid);//新建  
           cache[dsid] = fsb;//更新缓存  
           if(count.length > 100){//保正缓存的大小<=100  
              delete cache[count.shift()];  
           }  
           return fsb;        
       },  
   
       clearSearchBox : function(dsid){  
           if(dsid in cache){  
              cache[dsid].clearSelection();    
           }  
       }  
    };  
})();  
   
CachedSearchBox.attachSearchBox("input1");    
```
当第二次调用CachedSearchBox.attachSerachBox(“input1”)的时候，就可以从缓存中取道该对象，而不用再去创建一个新的searchbox对象。
#### 实现封装
在person之外的地方无法访问其内部的变量，而通过提供闭包的形式来访问：
```
<strong>var person = function(){  
    //变量作用域为函数内部，外部无法访问  
    var name = "default";     
     
    return {  
       getName : function(){  
           return name;  
       },  
       setName : function(newName){  
           name = newName;  
       }  
    }  
}();  
   
print(person.name);//直接访问，结果为undefined  
print(person.getName());  
person.setName("abruzzi");  
print(person.getName());</strong>  
得到结果如下：
undefined
default
abruzzi
```
闭包的另一个重要用途是实现面向对象中的对象，传统的对象语言都提供类的模板机制，这样不同的对象(类的实例)拥有独立的成员及状态，互不干涉。虽然JavaScript中没有类这样的机制，但是通过使用闭包，可以模拟出这样的机制：
```
function Person(){  
    var name = "default";     
     
    return {  
       getName : function(){  
           return name;  
       },  
       setName : function(newName){  
           name = newName;  
       }  
    }  
};  
   
   
var john = Person();  
print(john.getName());  
john.setName("john");  
print(john.getName());  
   
var jack = Person();  
print(jack.getName());  
jack.setName("jack");  
print(jack.getName());
运行结果如下：
default
john
default
jack
```
#### 内存泄漏
在不同的JavaScript解释器实现中，由于解释器本身的缺陷，使用闭包可能造成内存泄漏，内存泄漏是比较严重的问题，会严重影响浏览器的响应速度，降低用户体验，甚至会造成浏览器无响应等现象。
 
JavaScript的解释器都具备垃圾回收机制，一般采用的是引用计数的形式，如果一个对象的引用计数为零，则垃圾回收机制会将其回收，这个过程是自动的。但是，有了闭包的概念之后，这个过程就变得复杂起来了，在闭包中，因为局部的变量可能在将来的某些时刻需要被使用，因此垃圾回收机制不会处理这些被外部引用到的局部变量，而如果出现循环引用，即对象A引用B，B引用C，而C又引用到A，这样的情况使得垃圾回收机制得出其引用计数不为零的结论，从而造成内存泄漏。